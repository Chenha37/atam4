tks = 177560 ;which line in code?????????????????????????
tkb = 177562
tps = 177564
tpb = 177566
cls = 177546
NIL = 0
LEN1 = 50		;length of Welcome message
LEN2 = 6		;length of dollar
LEN3 = 27 		;length of starting message
LEN4 = 6 		;length of "white"/"black"
LEN5 = 12		;length of word "player is "/"move took "
LEN6 = 11		;length of word "Computer"
LEN7 = 5		;length of word "with "
LEN8 = 23		;length of word "seconds per move"
LEN9 = 25		;length of word "Board layout:"
LEN10 = 120 	;length of board
LEN11 = 15 		;length of " seconds."
LEN12 = 6 		;length of "Human" 
LEN13 = 20		;length of "Current Player: "
LEN14 = 2
LEN_ERROR=22

. = torg + 1000 

;---------------------------------------------------------------------------------------------
;|                                          main                                             |
;---------------------------------------------------------------------------------------------

main: 		mov #main, sp
			mov #printc, @#20
			mov #340, @#22
			mov #printc, @#64
			mov #200, @#66
			mov #100, @#tps
			mov #inp, @#60 			;keyboard Interrupt vector initialization
			mov #200, @#62
			mov #opnmsg, -(sp)
			mov #LEN1, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length   
			mov #clock, @#100
			mov #300, @#102
			bis #101,@#tks			;change IE,RE to 1
			
			
prdollar:  	mov #dollar, -(sp)
			mov #LEN2, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			bis #101,@#tks					
waiting:	wait
			br waiting				;wait to interrupt
			jmp checkinp
			;print the end message out of time use flag currplr
			halt
;---------------------------------------------------------------------------------------------
;|                                 checking if the input is legal                            |
;---------------------------------------------------------------------------------------------	
checkinp:
			mov #array,-(sp)
			cmp #'s,@(sp)
			bne check2
			add #2,(sp)
			cmp #'t,@(sp)
			bne check2
			add #2,(sp)
			cmp #'a,@(sp)
			bne check2
			add #2,(sp)
			cmp #'r,@(sp)
			bne check2
			add #2,(sp)
			cmp #'t,@(sp)
			bne check2
			add #2,(sp)
			cmp #' ,@(sp)
			bne error
			cmp startgm,0
			bne error
			br chkstart			
check2:     tst (sp)+
		    mov #array,-(sp)
			cmp #'m,@(sp)
			bne check3
			add #2,(sp)
			cmp #'o,@(sp)
			bne check3
			add #2,(sp)
			cmp #'v,@(sp)
			bne check3
			add #2,(sp)
			cmp #'e,@(sp)
			bne check3
			add #2,(sp)
			cmp #' ,@(sp)
			bne error
			cmp #1,startgm
			bne error
			jmp chkmove						
check3:		tst (sp)+
		    mov #array,-(sp)
			cmp #'s,@(sp)
			bne check4
			add #2,(sp)
			cmp #'t,@(sp)
			bne check4
			add #2,(sp)
			cmp #'o,@(sp)
			bne check4
			add #2,(sp)
			cmp #'p,@(sp)
			bne check4
			tst (sp)+
			jmp stop
			check4:		tst (sp)+
		    mov #array,-(sp)
			cmp #'t,@(sp)
			bne error
			add #2,(sp)
			cmp #'i,@(sp)
			bne error
			add #2,(sp)
			cmp #'m,@(sp)
			bne error
			add #2,(sp)
			cmp #'e,@(sp)
			bne error
			tst (sp)+
			jmp time	
error:		tst (sp)+
			mov #errormsg,-(sp)
			mov #LEN_ERROR,-(sp)
			jsr pc, printMsg
			add #4,sp
			mov #array,-(sp)
			mov LENARRAY,-(sp)
			jsr pc, printMsg
			add #4,sp
			mov #parnmsg,-(sp) 		;print " to close
			mov #1,-(sp)
			jsr pc, printMsg
			add #4,sp
			bis #1, @#tks
			jmp prdollar	
chkstart:   add #2,(sp)
			cmp #' ,@(sp)
			beq chkstart
			cmp #'c,@(sp)
			beq addcomp1
			cmp #'h,@(sp)
			bne error
			br addhumn1
addcomp1:	mov #cmptrmsg,type1
			add #2,(sp)
			cmp #' ,@(sp)
			bne error
			br time1
addhumn1:	mov #humanmsg,type1
			add #2,(sp)
			cmp #' ,@(sp)
			bne error
			br time1
time1:		mov r1,-(sp)
			clr r1
chkspac1:	add #2,2(sp)
			cmp #' ,@2(sp)
			beq chkspac1
			clr num1  				;before using as a counter of digits		
			clr num2				;before using as a counter of digits
addigit1:	cmp #60,@2(sp)
			bhi error
			cmp #72,@2(sp)
			blo error
			add @2(sp),r1
			
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			mov #timenum1,indxarr;
			add num1,indxarr
			mov @2(sp),@indxarr		;moving 1 digit
			add #2,num1
			
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			sub #60, r1
			add #2,2(sp)
			cmp #' ,@2(sp)
			beq endtime1
			mul #12,r1
			br addigit1
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
endtime1:	add #2,2(sp)
			cmp #' ,@2(sp)
			beq endtime1
			mov r1,timeW
			clr r1
			cmp #'c,@2(sp)
			beq addcomp2
			cmp #'h,@2(sp)
			bne error1
			br addhumn2
addcomp2:	mov #cmptrmsg,type2
			add #2,2(sp)
			cmp #' ,@2(sp)
			bne error1
			br time2				
addhumn2:	mov #humanmsg,type2
			add #2,2(sp)
			cmp #' ,@2(sp)
			bne error1
			br time2
time2:		add #2,2(sp)
			cmp #' ,@2(sp)
			beq time2
			;add #2,2(sp)
			cmp #60,@2(sp)
			bhi error1 ;;;;;;;;;;;;;;;;;;;
			cmp #72,@2(sp)
			blo error1
			add @2(sp),r1
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			mov #timenum2,indxarr;
			add num2,indxarr
			mov @2(sp),@indxarr			;moving 1 digit
			add #2,num2
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			sub #60,r1
addigit2:	add #2,2(sp)
			cmp #60,@2(sp)
			bhi endtime2
			cmp #72,@2(sp)
			blo endtime2
			mul #12,r1
			add @2(sp),r1
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			mov #timenum2,indxarr;
			add num2,indxarr
			mov @2(sp),@indxarr			;moving 1 digit
			add #2,num2
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			sub #60,r1
			br addigit2
error1:		jmp error
endtime2:	mov r1,timeB
			mov (sp)+,r1
			inc startgm
			tst (sp)+
			jmp start
chkmove:	mov r1,-(sp)
			clr r1
chkspac2:	add #2,2(sp)
			cmp #' ,@2(sp)
			beq chkspac2
			cmp #60,@2(sp)
			bhi error1
			cmp #67,@2(sp)
			blo error1
	        add @2(sp),r1
			sub #60, r1
			add #2,2(sp)
			mul #10,r1
			add @2(sp),r1
			sub #60,r1
			cmp #60,@2(sp)
			bhi error1
			cmp #67,@2(sp)
			blo error1
			add #2,2(sp)
			cmp #' ,@2(sp)
			bne error1
endtime3:	add #2,2(sp)
			cmp #' ,@2(sp)
			beq endtime3
			mov r1,src
			clr r1
			;add #2,2(sp)
			cmp #60,@2(sp)
			bhi error1
			cmp #67,@2(sp)
			blo error1
			add @2(sp),r1
			sub #60,r1
			add #2,2(sp)
			mul #10,r1
			add @2(sp),r1
			sub #60,r1
			cmp #60,@2(sp)
			bhi error1
			cmp #67,@2(sp)
			blo error1
endtime4:	mov r1,dest
			mov (sp)+,r1
			tst (sp)+
			
									clr r0           ;Initialize registers
			clr r1				
			clr r2
			clr r3
			cmp currplr,#0   
			beq black		 		
						  
		

white:  					
			clr r2
			clr r3
			cmp src,dest
			blos error1
			mov src,r0
			add r0,r0
			cmp Board(r0),#1
			bne error1
			mov dest,r1
			add r1,r1 
			cmp Board(r1),#0
			bne error1
			mov r0,r3
			div #20,r2        ;in order to understand in which line in the board the current token is 
			tst r2
			beq error3        ;if r2 is zero it means that the token can't move
			sub #16,r0
			cmp r0,r1
			beq rd1plr1
			sub #4,r0
			cmp r0,r1
			beq ld1plr1
			sub #12,r0
			cmp r0,r1
			beq rd2plr1
			sub #10,r0
			cmp r0,r1
			beq ld2plr1
error3:		jmp error
			
rd1plr1:	cmp #16,r3
			beq error3
			jmp endchkmov
ld1plr1:	cmp #0,r3
			beq error3
			jmp endchkmov
rd2plr1:	cmp #16,r3
			beq error3
			cmp #14,r3
			beq error3
			cmp r2,#1
			beq error3
			mov src,r4
			add src,r4
			sub #16,r4
			cmp Board(r4),#1
			beq error3
			cmp Board(r4),#0
			beq error3
			jmp endchkmov
ld2plr1:	cmp #0,r3
			beq error2
			cmp #2,r3
			beq error2
			cmp r2,#1
			beq error2
			mov src,r4
			add src,r4
			sub #22,r4
			cmp Board(r4),#1
			beq error2
			cmp Board(r4),#0
			beq error2
			jmp endchkmov
		 
black:  					
			clr r2
			clr r3
			cmp dest,src
			blos error2
			mov src,r0
			add r0,r0
			cmp Board(r0),#2
			bne error2
			mov dest,r1
			add r1,r1 
			cmp Board(r1),#0
			bne error2
			mov r0,r3
			div #20,r2        ;in order to understand in which line in the board the current token is 
			cmp r2,#7
			beq error2        ;if r2 is 7line it means that the token can't move
			
			add #16,r0
			cmp r0,r1
			beq ld1plr2
			
			add #4,r0
			cmp r0,r1
			beq rd1plr2
			
			
			add #12,r0
			cmp r0,r1
			beq ld2plr2
			
			add #10,r0
			cmp r0,r1
			beq rd2plr2
			jmp error2
ld1plr2:	cmp #0,r3
			beq error2
			jmp endchkmov
rd1plr2:	cmp #16,r3
			beq error2
			jmp endchkmov
ld2plr2:	cmp #0,r3
			beq error2
			cmp #2,r3
			beq error2
			cmp #6,r2
			beq error2
			mov src,r4
			add src,r4
			add #16,r4
			cmp Board(r4),#2
			beq error2
			cmp Board(r4),#0
			beq error2
			jmp endchkmov
rd2plr2:	cmp #16,r3
			beq error2
			cmp #14,r3
			beq error2
			cmp #6,r2
			mov src,r4
			add src,r4
			add #22,r4
			cmp Board(r4),#2
			beq error2
			cmp Board(r4),#0
			beq error2
			jmp endchkmov		
error2:		jmp error1
	
endchkmov:	
			bic #100,cls
			jmp move
			
			

			
;---------------------------------------------------------------------------------------------
;|                                            start                                           |
;---------------------------------------------------------------------------------------------			

start:				
			mov #100, @#tps
			mov #startmsg, -(sp)
			mov #LEN3, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			jsr pc, linedrop
			
			mov #whitemsg, -(sp)
			mov #LEN4, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			mov #playrmsg, -(sp)
			mov #LEN5, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			mov type1, -(sp)		;type1 holds the address of the ascii array to print (Human or Computer)
			jsr pc, printwho
			add #2,sp				;pop to the message (type)
			
			mov #withmsg, -(sp)
			mov #LEN7, -(sp)		;;;;;;;;;;;;;;;;;;;;;;;;;;;;?/???
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			;;;;;;;;;;;;;;;;;;;;;;;;;;;
			mov #timenum1,-(sp)
			mov num1,-(sp)
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;?/???
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			mov #scopnmsg, -(sp)
			mov #LEN8, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			jsr pc, linedrop
			
			mov #blackmsg, -(sp)
			mov #LEN4, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			mov #playrmsg, -(sp)
			mov #LEN5, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			mov type2, -(sp)		;type2 holds the address of the ascii array to print (Human or Computer)
			jsr pc,printwho
			add #2,sp				;pop to the message (type)
			
			mov #withmsg, -(sp)
			mov #LEN7, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			;;;;;;;;;;;;;;;;;;;;;;;;;;;
			mov #timenum2,-(sp)
			mov num2,-(sp)
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;?/???
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			mov #scopnmsg, -(sp)
			mov #LEN8, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			jsr pc, linedrop
			
busy_w2:	tstb @#tps 
			bpl busy_w2				;wait to the printer to be ready to print 
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;---------------------------------------------------------------------------------------------
;|                                            GAME                                           |
;---------------------------------------------------------------------------------------------				
											
;this functions will change the printed board by the change in the Board label			
chngbord:	mov #Board, pointer1	;initialization of pointer1 to the beginning of the board
			mov #wordbord, pointer2 ;initialization of pointer2 to the beginning of the word board
			add counter3, pointer1	;will put the current square address to update in the board in pointer1
			add counter4, pointer2	;will put the current square address to update in the word board in pointer2
			cmp counter3,#200 		;check if we reached to the end of the board 
			beq endchang			
			cmpb @pointer2, #'\r	
			beq fixplace			;check if it is enter (to skip on)
			cmp #0, @pointer1		;check if there is zero in the square
			beq change_				;if there is - go change to  in word board
			cmp #1, @pointer1		;check if there is zero in the square
			beq changeW				;if there is - go change to W in word board
			cmp #2, @pointer1		;check if there is zero in the square
			beq changeB				;if there is - go change to B in word board
change_:	movb #'_ , @pointer2	
			add #2, counter3		;move to next square on Board
			inc counter4			;move to next square on word board
			br chngbord
changeW:	movb #'W, @pointer2
			add #2, counter3
			inc counter4	
			br chngbord
changeB:	movb #'B, @pointer2
			add #2, counter3
			inc counter4
			br chngbord

fixplace:	add #2, counter4		;continue to next legal square to update (we are in enter)
			br chngbord
			
endchang:	
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			mov #boardlay, -(sp)
			mov #LEN9, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			mov #wordbord, -(sp)
			mov #LEN10, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
busy_w7:	tstb @#tps 
			bpl busy_w7				;wait to the printer to be ready to print 				 				

			jsr pc, linedrop
			cmp currplr,#1
			beq blacktrn
			
whitetrn:	;;;;;;;;sentences
			mov #Curntmsg, -(sp)
			mov #LEN13, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			mov #whitemsg, -(sp)
			mov #LEN4, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
 
			mov type1, -(sp)		;type2 holds the address of the ascii array to print (Human or Computer)
			jsr pc, printwho
			add #2,sp				;pop to the message (type)
 
			bis #100,cls
			inc currplr
			clr indxarr
			jmp prdollar
			
						
blacktrn:	;;;;sentences for current player
			mov #Curntmsg, -(sp)
			mov #LEN13, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			mov #blackmsg, -(sp)
			mov #LEN4, -(sp)
			jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			
			mov type2, -(sp)		;type2 holds the address of the ascii array to print (Human or Computer)
			jsr pc, printwho		;go to print Computer or Human 
			add #2,sp				;pop to the message and to the length
			
			bis #100,cls
			dec currplr
			clr indxarr
			jmp prdollar
			
	
stop:		halt
time:		halt
;---------------------------------------------------------------------------------------------
;|                                            move                                            |
;---------------------------------------------------------------------------------------------	
move:		bic #100,cls
			mov #Board,-(sp)
			jsr r5,movPiece
src:		.word 0
dest:		.word 0	
			tst (sp)+
			
			;~~~~~~~~~~~~~~~~~~~~ print time took message ~~~~~~~~~~~~~~~~~~~~~~~
			jsr pc, linedrop
			cmp currplr,#0		;check who is the player to print 
			beq blackprt		

whiteprt:	mov #whitemsg, -(sp)
			mov #LEN4, -(sp)		
			jsr pc, printMsg
			add #4,sp	
			
			mov type1, -(sp)		;type1 holds the address of the ascii array to print (Human or Computer)
			jsr pc, printwho
			add #2,sp				;pop to the message (the type)
			br contprt
			
blackprt:	mov #blackmsg, -(sp)
			mov #LEN4, -(sp)		
			jsr pc, printMsg
			add #4,sp
			
			mov type2, -(sp)		;type1 holds the address of the ascii array to print (Human or Computer)
			jsr pc, printwho
			add #2,sp				;pop to the message (type)

contprt:	mov #timemsg, -(sp)
			mov #LEN5, -(sp)		
			jsr pc, printMsg
			add #4,sp	
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			
			jsr pc, octTodec
			
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			mov #secmsg, -(sp)
			mov #LEN11, -(sp)		
			jsr pc, printMsg
			add #4,sp

busy_w5:	tstb @#tps 
			bpl busy_w5
			
			clr countsec		;initialization before using the clock again
			clr countrst		;initialization before using the clock again
			clr counter3
			clr counter4
		
			jmp chngbord
			
;---------------------------------------------------------------------------------------------
;|                                   general functions                                       |
;---------------------------------------------------------------------------------------------	

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ print a line drop (enter) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

linedrop:	mov #entermsg, -(sp)
			mov #2, -(sp)		
			jsr pc, printMsg
			add #4,sp
			rts pc 		

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ print a current player ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			
printwho:	mov 2(sp),-(sp) 		;copy the type to the top of the stack 
			cmpb #'C, @(sp)			
			beq itscomp				;check if the player that was entered is computer or human to print 
			mov #LEN12, -(sp)		;length of "Human" 
			br pascomp
itscomp:	mov #LEN6, -(sp)		;length of "Computer"
pascomp:	jsr pc, printMsg
			add #4,sp				;pop to the message and to the length
			rts pc 
			
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ print message ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;print a message of the data it gets in the stack (ascii array to print ant its length) 
printMsg:  	tst busy				;in order to check if the printer is busy (by a flag)
			bgt printMsg			;if the printer is busy - wait (by loop back to printMsg)
			mov #1, busy			;turn on the busy flag 
			mov 4(sp), pointer1		;pointer1 will point to the beginning of the array to print		
			mov 2(sp), counter1		;counter1 will hold the number of chars to print
			iot
			rts pc 
			
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ print octal in decimal ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

octTodec: 	mov r2, -(sp)			;keep the original value of r2
			mov r3, -(sp)			;keep the original value of r3
			clr r2					;clear r2 before use to div
			clr r3					;clear r3 before use to div
			mov countrst, r3 		;move the reminder of the time to r3 before div
			div #12, r2 			;div in 12 (10 in decimal)
			mov r2,r3 
			clr r2 
			div #12, r2 
			add #60, r2				;r2 will hold the 10th second of the reminder, change it to the ascii value
			mov r2, -(sp)
			mov #'., -(sp)			
			clr r2
			clr countoct			;use to know how many numbers to print  
			clr r3					;r3 will keep the reminder in each diversion 
			mov countsec, r3 		;move the seconds that passed to r3 before div
divsec:							
			div #12, r2				;to move to decimal number 
			add #60,r3 
			mov r3,-(sp)
			inc countoct
			mov r2, r3 
			clr r2 
			cmp r3, #12 			;check if we need to continue diverting 
			bge divsec				;if the number in r2 is bigger or equal to 12 (10) - keep diverting
			add #60, r3				;transfer to ascii value
			mov r3, -(sp)			;put the first number to print in the stack (LIFO)
			add #3,countoct			;number of chars to print with the first and last number and the point (.)
			
			;;print the number from sp
printoct:	tst countoct
			beq endoctal
			movb (sp),numbrmsg
			mov #numbrmsg,-(sp)
			mov #1,-(sp)			;the length to print 
			jsr pc, printMsg
			add #6,sp 			;will pop the first number to print and its length(1)
			dec countoct			;after print it, number of chars to print is decreased in 1
			br printoct
			
endoctal:	mov (sp)+, r3
			mov (sp)+, r2 
			rts pc 					;go back 
			
;---------------------------------------------------------------------------------------------
;|                                      commands                                             |
;---------------------------------------------------------------------------------------------



;---------------------------------------------------------------------------------------------
;|                                     interrupts                                            |
;---------------------------------------------------------------------------------------------
. = torg + 7000

;interrupt of the printer and iot 
printc: 	tst counter1 			;check number of words that left to print from array			
			ble fin					;if there is no word left to print
			movb @pointer1,@#tpb	;move the pointer1 to the word in the array to print
			inc pointer1			;will move the pointer1 to point to the next char
			dec counter1			;will decrease the number of words to print in 1
			rti
fin:		clr busy 				;will turn off the flag - 
			rti

;interrupt of the keyboard
inp: 		mov r0, -(sp)
			mov #array, r0 
			add indxarr, r0			;r0 will hold the address of the next available char 
			jsr pc, busy_w
			movb @#tkb, @#tpb 		;send input to the printer
			movb @#tkb, (r0)
			cmp @#tkb,#'\b
			beq backspce
			cmp @#tkb,#'\r
			beq enter1
			inc indxarr
			inc indxarr
			bis #1, @#tks			;restore RE bit
endinp:		mov (sp)+,r0
			bis #1, @#tks
			rti
			
enter1: 	jsr pc, busy_w
			movb #'\r ,@#tpb
			jsr pc, busy_w
			movb #'\n ,@#tpb
			jsr pc, busy_w
			movb #'\r ,@#tpb
			jsr pc, busy_w
			movb #'\n ,@#tpb
			mov indxarr,LENARRAY
			mov #0, indxarr
			mov (sp)+, r0
			add #2, (sp)
			rti
			
backspce:	jsr pc, busy_w
			movb #' ,@#tpb 
			jsr pc, busy_w
			movb #'\b, @#tpb
			dec indxarr
			dec indxarr
			jmp endinp
			
busy_w:		tstb @#tps 
			bpl busy_w				;wait to the printer to be ready to print	
			rts pc


clock:		inc countrst
			cmp #1000.,countrst	
			beq resett
			rti
resett:		clr countrst
			inc countsec
			cmp currplr, #0
			beq fintimB  
			cmp timeW,countsec
			beq endturn1
			rti
endturn1:   bic #100,@#cls
			add #6,(sp)
			rti
fintimB:	cmp timeB,countsec
			beq endturn2
			rti 	
endturn2:	bic #100,@#cls 
			add #6,(sp)
			rti
			
			
;---------------------------------------------------------------------------------------------
;|                                     Auxiliary functions                                   |
;---------------------------------------------------------------------------------------------
;movPiece - will update a current board by moving a token from one place to other (given places).
;r5 will hold (move parameter inline) the address of source and destination of the token.
movPiece: 	mov r0,-(sp) 		;keep current value of r0 in the stack
			mov r1,-(sp) 		;keep current value of r1 in the stack
			mov r2,-(sp) 		;keep current value of r2 in the stack
			mov r3,-(sp)		;keep current value of r3 in the stack
			mov r4,-(sp)		;keep current value of r4 in the stack
			clr r0 				;initialize register
			clr r1 				;initialize register
			clr r2 				;initialize register
			clr r3				;initialize register
			clr r4				;initialize register
			mov (r5)+,r0 		;r0 will hold the source point
			add r0,r0 			;will update the source point to right index (mul in 2, because a word is two bites)
			mov (r5)+,r1 		;r1 will hold the destination point
			add r1,r1 			;will update the destination point to right index (mul in 2, because a word is two bites)
			mov 14(sp),r2 		;r2 will hold the board address
			add r0,r2 			;r2 will be the pointer to the source place
			cmp (r2),#1			;check if the player to move is the white
			beq mov_1			;if the player to move is the white - branch to move it to the destination square
			cmp (r2),#2			;check if the player to move is the black
			beq mov_2			;if the player to move is the black - branch to move it to the destination square
			br endMovPiece		;in case that there is no white or black token at source - finish the function without chages
mov_1:		mov #2,r4 			;r4 will hold the enemy number
			clr (r2)			;will turn the source place to zero (as the token of the white moved from the current square)
			mov 14(sp),r2 		;r2 will hold the pointer to the beginning of the board 			
			add r1,r2 			;r2 will hold the destination point 
			mov #1,(r2)			;will update the destination square to 1 (as the white token moved to it) 
			br checkEat			;check if there is need to eat an enemy token 
mov_2:      mov #1,r4 			;r4 will hold the enemy number
			clr (r2)	 		;will turn the source place to zero (as the token of the black moved from the current square)
			mov 14(sp),r2 		;r2 will hold the pointer to the beginning of the board 			
			add r1,r2 			;r2 will hold the destination point 
			mov #2,(r2)			;will update the destination square to 1 (as the black token moved to it)
			br checkEat			;check if there is need to eat an enemy token 			
checkEat:	mov 14(sp),r2 		;r2 will hold the pointer to the beginning of the board 
			cmp r1,r0			;check which one of them is bigger
			bgt r1big			;check to eat when r1 is bigger than r0 
			br r0big			;check to eat when r0 is bigger than r1 
r1big:   	mov r1,r3 			;r3 will hold the destination point 
			sub r0,r3 			;r3 will hold a the difference of address between source and destination
			cmp r3,#22			;the most bigger difference in the upper line
			ble endMovPiece		;if the difference is lower or equal to 22 - there is no enemy to eat
			cmp r3,#34			;else - there is enemy to eat - it could be in a difference of 34/44 words
			beq eatrigt1		;eat in right diagonal
			cmp r3,#44
			beq eatleft1		;eat in left diagonal						
eatrigt1: 	add #16,r0			;will update the destination point to the point to eat the enemy
			add r0,r2 			;will add it to the board in order to eat
			tst (r2)			;will check if there is a token there
			beq retrnply		;will return the enemy player 
			clr (r2)			;will eat the enemy
			br endMovPiece		;finish after eat the enemy			
eatleft1:	add #22,r0			;will update the destination point to the point to eat the enemy
			add r0,r2 			;will add it to the board in order to eat
			tst (r2)			;will check if there is a token there
			beq retrnply		;will return the enemy player 
			clr (r2)			;will eat the enemy
			br endMovPiece		;finish after eat the enemy			
r0big:		mov r0,r3 			;r3 will hold the source point 
			sub r1,r3			;r3 will hold a the difference of address between source and destination
			cmp r3,#22			;the most bigger difference in the upper line
			ble endMovPiece		;if the difference is lower or equal to 22 - there is no enemy to eat
			cmp r3,#34			;else - there is enemy to eat - it could be in a difference of 34/44 words
			beq eatrigt0		;eat in right diagonal
			cmp r3,#44
			beq eatleft0		;eat in left diagonal			
eatrigt0: 	add #16,r1			;will update the destination point to the point to eat the enemy
			add r1,r2 			;will add it to the board in order to eat
			tst (r2)			;will check if there is a token there
			beq retrnply		;will return the enemy player 
			clr (r2)			;will eat the enemy
			br endMovPiece		;finish after eat the enemy			
eatleft0:  	add #22,r1			;will update the destination point to the point to eat the enemy
			add r1,r2 			;will add it to the board in order to eat
			tst (r2)			;will check if there is a token there
			beq retrnply		;will return the enemy player 
			clr (r2)			;will eat the enemy
			br endMovPiece		;finish after eat the enemy			
retrnply:   mov r4, (r2)		;will return the enemy's token
			br endMovPiece		;finish after bring the enemy back
endMovPiece:mov (sp)+,r4
			mov (sp)+,r3
			mov (sp)+,r2
			mov (sp)+,r1
			mov (sp)+,r0
			rts r5	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;			
				
			
			


. = torg + 10000

Board:		.word	0,	2,	0,	2,	0,	2,	0,	2
			.word	2,	0,	2,	0,	2,	0,	2,	0
			.word	0,	2,	0,	2,	0,	2,	0,	2
			.word	0,	0,	0,	0,	0,	0,	0,	0
			.word	0,	0,	0,	0,	0,	0,	0,	0
			.word	1,	0,	1,	0,	1,	0,	1,	0
			.word	0,	1,	0,	1,	0,	1,	0,	1
			.word	1,	0,	1,	0,	1,	0,	1,	0
			
. = torg + 11000

wordbord:	.ascii<_B_B_B_B\r\nB_B_B_B_\r\n_B_B_B_B\r\n________\r\n________\r\nW_W_W_W_\r\n_W_W_W_W\r\nW_W_W_W_\r\n>
			.even
	
opnmsg: 	.ascii<hello, welcome to chental checkers game!>	
			.even
			
dollar:  	.ascii<\r\n\r\n$ >
			.even
			
startmsg:	.ascii<\r\nStarting a new game\r\n\r\n>
			.even
			
whitemsg:	.ascii<White >
			.even
			
blackmsg:	.ascii<Black >
			.even
			
playrmsg:	.ascii<player is >
			.even
			
humanmsg:	.ascii<Human >
			.even
			
cmptrmsg:	.ascii<Computer >
			.even
			
Curntmsg:	.ascii<Current Player: >
			.even
			
withmsg:	.ascii<with >
			.even
			
scopnmsg:	.ascii< seconds per move\r\n\r\n>
			.even
			
boardlay:	.ascii<\r\nBoard layout:\r\n\r\n>
			.even
			
errormsg:	.ascii<\r\nCannot execute ">	
			.even
			
timemsg:	.ascii<move took >	
			.even
			
secmsg:		.ascii< seconds.\r\n\r\n>	
			.even
			
entermsg:	.ascii<\r\n>	
			.even
			
parnmsg:	.ascii<">	
			.even
			
numbrmsg:	.ascii<.>	
			.even

indxarr: 	.word 0 				;initialize number of chars in the array
array: 		.blkw 62 				;maximal chars to keep
counter1:	.word 0					;counter1 to number of words in array
busy:		.word 0 				;flag to check if printer is busy
pointer1: 	.blkw 1
startgm:	.word 0					;flag to check if the game started
LENARRAY:	.word 0
pointer2: 	.blkw 1
counter2:	.word 0					;used to board
type1:		.blkw 1
type2:		.blkw 1  
timeW:		.word 0
timeB:		.word 0
timenum1:	.blkw 16
timenum2:	.blkw 16
num1:		.word 0 
num2: 		.word 0	
currplr:    .word 0
counter3:	.word 0					;counter3 to number board change
counter4:	.word 0					;counter4 to number board change
countrst:	.word 0
countsec:	.word 0
countoct:	.word 0 				;counter to the function which changes from octal to decimal number 





. = torg + 20000	
rate: .word 1000.


